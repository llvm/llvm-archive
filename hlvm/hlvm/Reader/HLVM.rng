<?xml version="1.0" encoding="UTF-8"?>
<!--=========================================================================-->
<!-- Copyright (C) 2006 Reid Spencer. All Rights Reserved.                   -->
<!--                                                                         -->
<!-- This software is free software; you can redistribute it and/or modify it-->
<!-- under the terms of the GNU Lesser General Public License as published by-->
<!-- the Free Software Foundation; either version 2.1 of the License, or (at -->
<!-- your option) any later version.                                         -->
<!--                                                                         -->
<!-- This software is distributed in the hope that it will be useful, but    -->
<!-- WITHOUT ANY WARRANTY; without even the implied warranty of              -->
<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser-->
<!-- General Public License for more details.                                -->
<!--                                                                         -->
<!-- You should have received a copy of the GNU Lesser General Public License-->
<!-- along with this library in the file named LICENSE.txt; if not, write to -->
<!-- the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,    -->
<!-- Boston, MA 02110-1301 USA                                               -->
<!--                                                                         -->
<!--=========================================================================-->
<!-- @file hlvm/Reader/HLVM.rng                                              -->
<!-- @author Reid Spencer <rspencer@reidspencer.com> (original author)       -->
<!-- @date 2006/05/13                                                        -->
<!-- @since 0.1.0                                                            -->
<!-- @brief Defines the core XPL language via Relax/NG Schema                -->
<!--=========================================================================-->
<!-- HLVM AST Schema                                                         -->
<!--                                                                         -->
<!-- This file contains the Relax/NG schema for construction of the HLVM AST -->
<!-- via an XML syntax. The schema aims to be simple and closely match the   -->
<!-- construction of an HLVM AST.                                            -->
<!--                                                                         -->
<!-- For full commentary on this schema, see http://hlvm.org/docs/XML.html   -->
<!--                                                                         -->
<!--=========================================================================-->

<grammar 
  datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
  xmlns ="http://relaxng.org/ns/structure/1.0"
  xmlns:a="http://relaxng.org/ns/annotation/1.0"
  ns="http://hlvm.org/src/hlvm/Reader/XML/HLVM.rng">

  <start>
    <ref name="hlvm.elem"/>
  </start>

  <!-- PATTERN DEFINITIONS FOR DATA TYPES -->

  <define name="Identifier.type">
    <choice>
      <ref name="Unprefixed_Identifier.type"/>
      <ref name="Prefixed_Identifier.type"/>
    </choice>
  </define>

  <define name="Unprefixed_Identifier.type">
    <data type="string">
      <param name="pattern">[^:]+</param>
      <param name="maxLength">1024</param>
    </data>
  </define>

  <define name="Prefixed_Identifier.type">
    <data type="string">
      <param name="pattern">[^:]+:[^:]+</param>
      <param name="maxLength">1024</param>
    </data>
  </define>

  <define name="C_Identifier.type">
    <data type="string">
      <param name="pattern">[A-Za-z_][A-Za-z0-9_]*</param>
      <param name="maxLength">256</param>
    </data>
  </define>

  <define name="Boolean.type">
    <choice>
      <data type="boolean"/>
      <value>TRUE</value>
      <value>True</value>
      <value>yes</value>
      <value>Yes</value>
      <value>YES</value>
      <value>1</value>
      <value>FALSE</value>
      <value>False</value>
      <value>no</value>
      <value>No</value>
      <value>NO</value>
      <value>0</value>
    </choice>
  </define>

  <!-- DOCUMENTATION OF HLVM AST PROGRAMS -->

  <define name="Documentation.pat">
    <optional>
      <element name="doc">
        <zeroOrMore>
          <choice>
            <text/>
            <ref name="Any.pat"/> <!-- should really be XHTML elements -->
          </choice>
        </zeroOrMore>
      </element>
    </optional>
  </define>

  <define name="Any.pat">
    <element>
      <anyName/>
      <zeroOrMore>
        <choice>
          <attribute>
            <anyName/>
          </attribute>
          <text/>
          <ref name="Any.pat"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>

  <!-- PATTERNS THAT DEFINE name AND type ATTRIBUTES -->

  <define name="Named_Element.pat">
    <attribute name="id">
      <ref name="Identifier.type"/>
    </attribute>
    <ref name="Documentation.pat"/>
  </define>

  <define name="Typed_Element.pat">
    <attribute name="type">
      <ref name="Identifier.type"/>
    </attribute>
    <ref name="Documentation.pat"/>
  </define>

  <define name="Named_Typed_Element.pat">
    <attribute name="id">
      <ref name="Identifier.type"/>
    </attribute>
    <attribute name="type">
      <ref name="Identifier.type"/>
    </attribute>
    <ref name="Documentation.pat"/>
  </define>

  <!-- HLVM PATTERN -->
  <define name="hlvm.elem">
    <element name="hlvm">
      <attribute name="pubid"><data type="anyURI"/></attribute>
      <ref name="Documentation.pat"/>
      <oneOrMore>
        <ref name="bundle.elem"/>
      </oneOrMore>
    </element>
  </define>

  <!--BUNDLES PATTERN -->

  <define name="bundle.elem">
    <element name="bundle">
      <ref name="Named_Element.pat"/>
      <ref name="Documentation.pat"/>
      <zeroOrMore>
        <ref name="import.elem"/>
      </zeroOrMore>
      <zeroOrMore>
        <choice>
          <ref name="alias.elem"/>
          <ref name="array.elem"/>
          <ref name="atom.elem"/>
          <ref name="enumeration.elem"/>
          <ref name="pointer.elem"/>
          <ref name="structure.elem"/>
          <ref name="signature.elem"/>
          <ref name="vector.elem"/>
          <ref name="opaque.elem"/>
          <ref name="variable.elem"/>
          <ref name="function.elem"/>
          <ref name="program.elem"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>

  <define name="import.elem">
    <element name="import">
      <attribute name="prefix">
        <ref name="Identifier.type"/>
      </attribute>
      <attribute name="pubid">
        <data type="anyURI"/>
      </attribute>
      <ref name="Documentation.pat"/>
    </element>
  </define>

  <!--PATTERNS FOR DEFINING TYPES -->

  <define name="alias.elem">
    <element name="alias">
      <ref name="Named_Element.pat"/>
      <attribute name="renames"><ref name="Identifier.type"/></attribute>
    </element>
  </define>

  <define name="intrinsic.elem">
    <element name="intrinsic">
      <attribute name="is">
        <ref name="Intrinsic_Atoms.type"/>
      </attribute>
    </element>
  </define>

  <define name="signed.elem">
    <element name="signed">
      <attribute name="bits">
        <ref name="Integer.type"/>
      </attribute>
    </element>
  </define>

  <define name="unsigned.elem">
    <element name="unsigned">
      <attribute name="bits">
        <ref name="Integer.type"/>
      </attribute>
    </element>
  </define>

  <define name="range.elem">
    <element name="range">
      <attribute name="min">
        <ref name="Integer.type"/>
      </attribute>
      <attribute name="max">
        <ref name="Integer.type"/>
      </attribute>
    </element>
  </define>

  <define name="real.elem">
    <element name="real">
      <attribute name="precision">
        <ref name="Integer.type"/>
      </attribute>
    </element>
  </define>

  <define name="atom.elem">
    <element name="atom">
      <ref name="Named_Element.pat"/>
      <choice>
        <ref name="intrinsic.elem"/>
        <ref name="signed.elem"/>
        <ref name="unsigned.elem"/>
        <ref name="range.elem"/>
        <ref name="real.elem"/>
      </choice>
    </element>
  </define>

  <define name="Intrinsic_Atoms.type">
    <choice>
      <value>any</value>
      <value>bool</value>
      <value>buffer</value>
      <value>char</value>
      <value>f32</value>
      <value>f44</value>
      <value>f64</value>
      <value>f80</value>
      <value>f128</value>
      <value>octet</value>
      <value>s8</value>
      <value>s16</value>
      <value>s32</value>
      <value>s64</value>
      <value>s128</value>
      <value>stream</value>
      <value>text</value>
      <value>u8</value>
      <value>u16</value>
      <value>u32</value>
      <value>u64</value>
      <value>u128</value>
      <value>void</value>
    </choice>
  </define>

  <define name="enumeration.elem">
    <element name="enumeration">
      <ref name="Named_Element.pat"/>
      <oneOrMore>
        <element name="enumerator">
          <attribute name="id">
            <ref name="Unprefixed_Identifier.type"/>
          </attribute>
          <ref name="Documentation.pat"/>
        </element>
      </oneOrMore>
    </element>
  </define>

  <define name="pointer.elem">
    <element name="pointer">
      <ref name="Named_Element.pat"/>
      <attribute name="to"><ref name="Identifier.type"/></attribute>
    </element>
  </define>

  <define name="vector.elem">
    <element name="vector">
      <ref name="Named_Element.pat"/>
      <attribute name="of">
        <ref name="Intrinsic_Atoms.type"/>
      </attribute>
      <attribute name="length"><data type="nonNegativeInteger"/></attribute>
    </element>
  </define>

  <define name="array.elem">
    <element name="array">
      <ref name="Named_Element.pat"/>
      <attribute name="length"><data type="nonNegativeInteger"/></attribute>
      <attribute name="of"><ref name="Identifier.type"/></attribute>
    </element>
  </define>

  <define name="structure.elem">
    <element name="structure">
      <ref name="Named_Element.pat"/>
      <zeroOrMore>
        <element name="field">
          <ref name="Named_Typed_Element.pat"/>
        </element>
      </zeroOrMore>
    </element>
  </define>

  <define name="signature.elem">
    <element name="signature">
      <ref name="Named_Element.pat"/>
      <attribute name="result"><ref name="Identifier.type"/></attribute>
      <optional>
        <attribute name="varargs"><ref name="Boolean.type"/></attribute>
      </optional>
      <zeroOrMore>
        <element name="arg">
          <ref name="Named_Typed_Element.pat"/>
        </element>
      </zeroOrMore>
    </element>
  </define>

  <define name="opaque.elem">
    <element name="opaque">
      <ref name="Named_Element.pat"/>
      <empty/>
    </element>
  </define>

  <!--PATTERNS FOR VARIABLES-->

  <define name="variable.elem">
    <element name="variable">
      <ref name="Named_Typed_Element.pat"/>
      <optional>
        <attribute name="const"><data type="boolean"/></attribute>
      </optional>
      <optional>
        <choice>
          <element name="init">
            <ref name="Constant.pat"/>
          </element>
          <element name="zero">
            <empty/>
          </element>
        </choice>
      </optional>
      <optional>
        <attribute name="linkage">
          <ref name="Linkage.type"/>
        </attribute>
      </optional>
    </element>
  </define>

  <define name="Linkage.type">
    <choice>
      <value>appending</value>
      <value>external</value>
      <value>internal</value>
      <value>linkonce</value>
      <value>weak</value>
    </choice>
  </define>

  <!--PATTERNS FOR FUNCTIONS -->

  <define name="function.elem">
    <element name="function">
      <ref name="Named_Typed_Element.pat"/>
      <optional>
        <attribute name="linkage"><ref name="Linkage.type"/></attribute>
      </optional>
      <choice>
        <element name="as"><ref name="C_Identifier.type"/></element>
        <zeroOrMore>
          <ref name="block.elem"/>
        </zeroOrMore>
      </choice>
    </element>
  </define>

  <define name="program.elem">
    <element name="program">
      <ref name="Named_Element.pat"/>
      <optional>
        <attribute name="linkage"><ref name="Linkage.type"/></attribute>
      </optional>
      <zeroOrMore>
        <ref name="block.elem"/>
      </zeroOrMore>
    </element>
  </define>

  <define name="Block.pat">
    <oneOrMore>
      <choice>
        <ref name="Operators.pat"/>
        <ref name="block.elem"/>
      </choice>
    </oneOrMore>
  </define>

  <define name="block.elem">
    <element name="block">
      <optional>
        <attribute name="label"><ref name="Identifier.type"/></attribute>
      </optional>
      <ref name="Block.pat"/>
    </element>
  </define>

  <!-- PATTERNS FOR DEFINING CONSTANTS -->

  <define name="Constant.pat">
    <choice>
      <ref name="Literal.pat"/>
      <!-- 
      FIXME: This is hacked out right now because it causes infinite recursion
      in libxml2 function xmlRelaxNGGetElements. Debugging it didn't help me
      find out why.
      <ref name="ConstantExpression.pat"/>
      -->
    </choice>
  </define>

  <define name="ref.elem">
    <element name="ref">
      <attribute name="id">
        <ref name="Identifier.type"/>
      </attribute>
      <ref name="Documentation.pat"/>
    </element>
  </define>

  <define name="ConstantExpression.pat">
    <choice>
      <ref name="index.elem"/>
      <ref name="cast.elem"/>
      <ref name="select.elem"/>
      <ref name="sizeof.elem"/>
      <ref name="addrof.elem"/>
      <ref name="extract.elem"/>
      <ref name="insert.elem"/>
      <ref name="shuffle.elem"/>
      <ref name="ComparisonOperators.pat"/>
      <ref name="UnaryArithmeticOperators.pat"/>
      <ref name="BinaryArithmeticOperators.pat"/>
      <ref name="BinaryBitwiseOperators.pat"/>
    </choice>
  </define>

  <!-- PATTERNS FOR LITERAL CONSTANTS -->

  <define name="Literal.pat">
    <choice>
      <ref name="IntegerLiteral.pat"/>
      <ref name="Boolean_Literal.elem"/>
      <ref name="Character_Literal.elem"/>
      <ref name="Real_Literal.elem"/>
      <ref name="Text_Literal.elem"/>
      <ref name="Null_Literal.elem"/>
      <ref name="Array_Literal.elem"/>
      <ref name="Vector_Literal.elem"/>
      <ref name="Structure_Literal.elem"/>
    </choice>
  </define>

  <define name="IntegerLiteral.pat">
    <choice>
      <ref name="Binary_Literal.elem"/>
      <ref name="Octal_Literal.elem"/>
      <ref name="Decimal_Literal.elem"/>
      <ref name="Hexadecimal_Literal.elem"/>
    </choice>
  </define>

  <define name="Integer.type">
    <choice>
      <ref name="Binary.type"/>
      <ref name="Octal.type"/>
      <ref name="Decimal.type"/>
      <ref name="Hexadecimal.type"/>
    </choice>
  </define>

  <define name="Typed_Literal.pat">
    <optional>
      <attribute name="type">
        <ref name="Identifier.type"/>
      </attribute>
    </optional>
  </define>

  <define name="Binary_Literal.elem">
    <element name="bin">
      <ref name="Typed_Literal.pat"/>
      <ref name="Binary.type"/>
    </element>
  </define>

  <define name="Binary.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">[01]+</param>
    </data>
  </define>

  <define name="Octal_Literal.elem">
    <element name="oct">
      <ref name="Typed_Literal.pat"/>
      <ref name="Octal.type"/>
    </element>
  </define>

  <define name="Octal.type" >
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">[0-7]+</param>
    </data>
  </define>

  <define name="Decimal_Literal.elem">
    <element name="dec">
      <ref name="Typed_Literal.pat"/>
      <ref name="Decimal.type"/>
    </element>
  </define>

  <define name="Decimal.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">[+\-]?\d+</param>
    </data>
  </define>

  <define name="Hexadecimal_Literal.elem">
    <element name="hex">
      <ref name="Typed_Literal.pat"/>
      <ref name="Hexadecimal.type"/>
    </element>
  </define>

  <define name="Hexadecimal.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">([0-9A-Fa-f][0-9A-Fa-f])+</param>
    </data>
  </define>

  <define name="Boolean_Literal.elem">
    <choice>
      <element name="true">
        <empty/>
      </element>
      <element name="false">
        <empty/>
      </element>
    </choice>
  </define>

  <define name="Character_Literal.elem">
    <element name="char">
      <ref name="Character.type"/>
    </element>
  </define>

  <define name="Text_Literal.elem">
    <element name="text">
      <text/>
    </element>
  </define>

  <define name="Character.type">
    <choice>
      <data type="string">
        <param name="length">1</param>
      </data>
      <data type="string">
        <param name="length">5</param>
        <param name="pattern">[#][0-9A-Fa-f]{4,4}</param>
      </data>
    </choice>
  </define>

  <define name="Real_Literal.elem">
    <choice>
      <element name="flt">
        <ref name="Real.type"/>
      </element>
      <element name="dbl">
        <ref name="Real.type"/>
      </element>
    </choice>
  </define>

  <define name="Real.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">ninf|pinf|nan|signan|zero|nzero|[+\-]?0x[0-9A-Fa-f](\.[0-9A-Fa-f]+)?p[-+][0-9]+|#[0-9A-Fa-f]{16}|#[0-9a-fA-F]{8}|[+\-]?\d+\.\d*([Ee][+\-]?\d+)?</param>
    </data>
  </define>

  <define name="Null_Literal.elem">
    <element name="null">
      <empty/>
    </element>
  </define>

  <define name="Array_Literal.elem">
    <element name="arr">
      <ref name="Typed_Element.pat"/>
      <oneOrMore>
        <ref name="Constant.pat"/>
      </oneOrMore>
    </element>
  </define>

  <define name="Vector_Literal.elem">
    <element name="vect">
      <ref name="Typed_Element.pat"/>
      <oneOrMore>
        <ref name="Constant.pat"/>
      </oneOrMore>
    </element>
  </define>

  <define name="Structure_Literal.elem">
    <element name="struct">
      <ref name="Typed_Element.pat"/>
      <oneOrMore>
        <ref name="Constant.pat"/>
      </oneOrMore>
    </element>
  </define>

  <!-- PATTERNS FOR OPERATORS -->

  <define name="Value.pat">
    <choice>
      <ref name="Operators.pat"/>
      <ref name="Constant.pat"/>
    </choice>
  </define>

  <define name="Location.pat">
    <choice>
      <ref name="ref.elem"/>
      <ref name="index.elem"/>
    </choice>
  </define>

  <define name="Operators.pat">
    <choice>
      <ref name="autovar.elem"/>
      <ref name="ComparisonOperators.pat"/>
      <ref name="UnaryArithmeticOperators.pat"/>
      <ref name="BinaryArithmeticOperators.pat"/>
      <ref name="BinaryBitwiseOperators.pat"/>
      <ref name="MemoryOps.pat"/>
      <ref name="InputOutputOps.pat"/>
      <ref name="ControlFlowOps.pat"/>
      <ref name="Literal.pat"/>
    </choice>
  </define>

  <define name="cast.elem">
    <empty/>
  </define>

  <define name="select.elem">
    <empty/>
  </define>

  <define name="sizeof.elem">
    <empty/>
  </define>

  <define name="addrof.elem">
    <ref name="Value.pat"/>
  </define>

  <define name="extract.elem">
    <empty/>
  </define>

  <define name="insert.elem">
    <empty/>
  </define>

  <define name="shuffle.elem">
    <empty/>
  </define>

  <define name="autovar.elem">
    <element name="autovar">
      <ref name="Named_Typed_Element.pat"/>
      <choice>
        <ref name="Constant.pat"/>
        <element name="zero">
          <empty/>
        </element>
      </choice>
    </element>
  </define>

  <define name="MemoryOps.pat">
    <choice>
      <ref name="load.elem"/>
      <ref name="store.elem"/>
      <ref name="index.elem"/>
      <ref name="length.elem"/>
    </choice>
  </define>

  <define name="load.elem">
    <element name="load">
      <ref name="Documentation.pat"/>
      <ref name="Location.pat"/>
    </element>
  </define>

  <define name="store.elem">
    <element name="store">
      <ref name="Documentation.pat"/>
      <ref name="Location.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="index.elem">
    <element name="index">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
      <oneOrMore>
        <ref name="Value.pat"/>
      </oneOrMore>
    </element>
  </define>

  <define name="length.elem">
    <element name="length">
      <ref name="Documentation.pat"/>
      <ref name="Location.pat"/>
    </element>
  </define>

  <define name="InputOutputOps.pat">
    <choice>
      <ref name="open.elem"/>
      <ref name="close.elem"/>
      <ref name="write.elem"/>
      <!-- <ref name="read.elem"/>
      <ref name="seek.elem"/>
      <ref name="tell.elem"/>
      <ref name="info.elem"/> -->
    </choice>
  </define>

  <define name="open.elem">
    <element name="open">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="close.elem">
    <element name="close">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="write.elem">
    <element name="write">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="read.elem">
    <element name="read">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="UnaryArithmeticOperators.pat">
    <choice>
      <ref name="neg.elem"/>
      <ref name="cmpl.elem"/>
    </choice>
  </define>

  <define name="neg.elem">
    <element name="neg">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="cmpl.elem">
    <element name="cmpl">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="BinaryArithmeticOperators.pat">
    <choice>
      <ref name="add.elem"/>
      <ref name="sub.elem"/>
    </choice>
  </define>

  <define name="add.elem">
    <element name="add">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>
      
  <define name="sub.elem">
    <element name="sub">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="BinaryBitwiseOperators.pat">
    <choice>
      <ref name="bor.elem"/>
      <ref name="band.elem"/>
    </choice>
  </define>

  <define name="bor.elem">
    <element name="bor">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="band.elem">
    <element name="band">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="ComparisonOperators.pat">
    <choice>
      <ref name="eq.elem"/>
      <ref name="ne.elem"/>
    </choice>
  </define>

  <define name="eq.elem">
    <element name="eq">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="ne.elem">
    <element name="ne">
      <ref name="Documentation.pat"/>
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="ControlFlowOps.pat">
    <choice>
      <ref name="ret.elem"/>
    </choice>
  </define>

  <define name="ret.elem">
    <element name="ret">
      <ref name="Operators.pat"/>
    </element>
  </define>
</grammar>
